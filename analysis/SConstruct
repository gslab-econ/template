# Preliminaries
import os
import sys
import atexit
import yaml
sys.path.append('../config')
sys.dont_write_bytecode = True # Don't write .pyc files

# Setup
from configuration import configuration
[mode, vers, cache_dir] = configuration(ARGUMENTS)
import gslab_scons as gs

# Start log
gs.log.start_log(mode, vers)

# Define the SCons environment
env = Environment(ENV = {'PATH': os.environ['PATH']}, 
                  IMPLICIT_COMMAND_DEPENDENCIES = 0,
                  BUILDERS = {
                              # 'BuildMatlab': Builder(action = gs.build_matlab),
                              'BuildPython': Builder(action = gs.build_python),
                              # 'BuildR'     : Builder(action = gs.build_r),
                              # 'BuildStata' : Builder(action = gs.build_stata),
                              })

# Only computes hash if time-stamp changed
env.Decider('MD5-timestamp') 
# Extensions to be used when scanning for source files in BuildLyx.
env.EXTENSIONS = ['.eps', '.pdf', '.lyx']
SourceFileScanner.add_scanner('.lyx', Scanner(gs.misc.lyx_scan, recursive = True))
# Load Stata executable if Stata builder is defined
if 'BuildStata' in env['BUILDERS'].keys():
    env['stata_executable'] = gs.misc.load_yaml_value('config_user.yaml', 'stata_executable')
# Load global and user config file, record contents of their external directories
for config_type in ['global', 'user']:
   config_file = 'config_%s.yaml' % config_type
   if os.path.isfile(config_file):
       config_paths = 'paths_%s' % config_type
       env[config_paths] = yaml.load(open(config_file, 'rU'))
   else:
       continue
   if 'external' in env[config_paths].keys() and type(env[config_paths]['external']) is dict:
       for name, path in env[config_paths]['external'].iteritems():
           gs.record_dir.record_dir(path, name)

# Export environment
Export('env')

# Run sub-trees
SConscript('source/prepare_data/SConscript')
SConscript('source/descriptive/SConscript')
Default('./build', './release')

# Additional mode options
if mode == 'cache':
    CacheDir(cache_dir)

# Debrief args is a dictionary storing the arguments that are useful for functions to run 
# after all Scons targets have been built. Scons_debrief will pass these args into those functions. 
debrief_args = {
               'look_in'            : 'release;source',    # Folders to look in for large versioned files
               'file_MB_limit_lfs'  : 2,                   # Soft limit on file size (w/ LFS);
               'total_MB_limit_lfs' : 500,                 # Soft limit on total size (w/ LFS);  
               'file_MB_limit'      : 0.5,                 # Soft limit on file size (w/o LFS);
               'total_MB_limit'     : 125,                 # Soft limit on total size (w/o LFS);  
               'lfs_required'       : gs.misc.load_yaml_value('config_global.yaml', 'prereq_git-lfs'), # Check if the repo requires LFS
               'git_attrib_path'    : '../.gitattributes', # .gitattributes location
               'MAXIT'              : 10,                  # max number of iterations to write file information to log
               'log'                : 'state_of_repo.log'  # state of repo log file location
               }

atexit.register(gs.log.end_log)
atexit.register(gs.misc.scons_debrief, args = debrief_args)
